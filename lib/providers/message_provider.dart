import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:relo/services/service_locator.dart';
import 'package:relo/services/secure_storage_service.dart';
import 'package:relo/services/app_notification_service.dart';

class MessageProvider extends ChangeNotifier {
  int _unreadConversationCount = 0;
  StreamSubscription? _webSocketSubscription;
  String? _currentUserId;
  Timer? _debounceTimer;

  int get unreadConversationCount => _unreadConversationCount;

  bool get hasUnread => _unreadConversationCount > 0;

  MessageProvider() {
    _init();
  }

  Future<void> _init() async {
    await _getCurrentUserId();
    await _loadUnreadCount();
    _listenToWebSocket();
  }

  Future<void> _getCurrentUserId() async {
    final secureStorage = const SecureStorageService();
    _currentUserId = await secureStorage.getUserId();
  }

  Future<void> _loadUnreadCount() async {
    try {
      final messageService = ServiceLocator.messageService;
      final conversations = await messageService.fetchConversations();

      if (_currentUserId == null) {
        _unreadConversationCount = 0;
        notifyListeners();
        return;
      }

      int unreadCount = 0;
      for (var conversation in conversations) {
        final seenIds = List<String>.from(conversation['seenIds'] ?? []);
        if (!seenIds.contains(_currentUserId)) {
          unreadCount++;
        }
      }

      _unreadConversationCount = unreadCount;
      notifyListeners();
    } catch (e) {
      debugPrint('Error loading unread conversation count: $e');
    }
  }

  void _listenToWebSocket() {
    _webSocketSubscription?.cancel();
    _webSocketSubscription = ServiceLocator.websocketService.stream.listen((
      message,
    ) {
      try {
        final data = jsonDecode(message);

        // Handle new message
        if (data['type'] == 'new_message') {
          _handleNewMessage(data['payload']);
        }

        // Handle conversation seen/read
        if (data['type'] == 'conversation_seen') {
          _handleConversationSeen(data['payload']);
        }
      } catch (e) {
        debugPrint('Error handling WebSocket message in MessageProvider: $e');
      }
    });
  }

  void _handleNewMessage(Map<String, dynamic>? payload) async {
    if (payload == null || _currentUserId == null) return;

    final conversationData = payload['conversation'];
    if (conversationData == null) return;

    final seenIds = List<String>.from(conversationData['seenIds'] ?? []);

    // Ki·ªÉm tra n·∫øu tin nh·∫Øn t·ª´ ch√≠nh m√¨nh th√¨ kh√¥ng tƒÉng unread count
    final messageData = payload['message'];
    if (messageData != null && messageData['senderId'] == _currentUserId) {
      return;
    }

    // KH√îNG hi·ªÉn th·ªã local notification t·ª´ WebSocket khi app ƒëang m·ªü
    // Ch·ªâ hi·ªÉn th·ªã notification khi app ·ªü background/terminated (t·ª´ FCM)
    // Notification s·∫Ω ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi Firebase background handler
    debugPrint(
      'üì± New message via WebSocket - not showing notification (app is foreground)',
    );

    // N·∫øu conversation ch∆∞a ƒë∆∞·ª£c ƒë·ªçc (ch∆∞a c√≥ currentUserId trong seenIds)
    if (!seenIds.contains(_currentUserId)) {
      // Debounce ƒë·ªÉ tr√°nh reload qu√° nhi·ªÅu l·∫ßn khi c√≥ nhi·ªÅu tin nh·∫Øn li√™n ti·∫øp
      _debounceTimer?.cancel();
      _debounceTimer = Timer(const Duration(milliseconds: 500), () {
        _loadUnreadCount();
      });
    }
  }

  Future<void> _showMessageNotification(
    Map<String, dynamic>? messageData,
    Map<String, dynamic> conversationData,
    String conversationId,
  ) async {
    if (messageData == null) return;

    // Ki·ªÉm tra n·∫øu ƒëang ·ªü m√†n h√¨nh chat c·ªßa conversation n√†y th√¨ kh√¥ng hi·ªÉn th·ªã
    // Note: ƒê∆°n gi·∫£n h√≥a - s·∫Ω hi·ªÉn th·ªã notification, user c√≥ th·ªÉ b·ªè qua n·∫øu ƒëang ·ªü m√†n h√¨nh chat
    // V√¨ vi·ªác ki·ªÉm tra route ch√≠nh x√°c ph·ª©c t·∫°p v√† kh√¥ng c·∫ßn thi·∫øt

    try {
      final notificationService = AppNotificationService();

      // L·∫•y th√¥ng tin sender
      final senderId = messageData['senderId'] as String?;
      if (senderId == null || senderId == _currentUserId) return;

      // L·∫•y th√¥ng tin conversation
      final isGroup = conversationData['isGroup'] as bool? ?? false;

      // ∆Øu ti√™n l·∫•y senderName t·ª´ message_data (backend ƒë√£ g·ª≠i s·∫µn)
      String senderName = messageData['senderName'] as String? ?? 'Ng∆∞·ªùi d√πng';
      String? senderAvatar = messageData['avatarUrl'] as String?;

      // N·∫øu kh√¥ng c√≥ senderName trong message_data, th·ª≠ l·∫•y t·ª´ participantsInfo
      if (senderName == 'Ng∆∞·ªùi d√πng') {
        final participantsInfo = conversationData['participantsInfo'] as List?;
        if (participantsInfo != null) {
          for (var p in participantsInfo) {
            if (p is Map && p['userId'] == senderId) {
              senderName = p['displayName'] as String? ?? 'Ng∆∞·ªùi d√πng';
              if (senderAvatar == null) {
                senderAvatar = p['avatarUrl'] as String?;
              }
              break;
            }
          }
        }
      }

      // N·∫øu v·∫´n kh√¥ng t√¨m th·∫•y, th·ª≠ t·ª´ participants
      if (senderName == 'Ng∆∞·ªùi d√πng') {
        final participants = List<Map<String, dynamic>>.from(
          conversationData['participants'] ?? [],
        );
        for (var p in participants) {
          if (p['userId'] == senderId) {
            senderName = p['displayName'] as String? ?? 'Ng∆∞·ªùi d√πng';
            if (senderAvatar == null) {
              senderAvatar = p['avatarUrl'] as String?;
            }
            break;
          }
        }
      }

      // N·∫øu v·∫´n kh√¥ng t√¨m th·∫•y, fetch t·ª´ UserService (fallback)
      if (senderName == 'Ng∆∞·ªùi d√πng') {
        try {
          debugPrint('üì± Fetching user info for senderId: $senderId');
          final userService = ServiceLocator.userService;
          final user = await userService.getUserById(senderId);
          senderName = user.displayName.isNotEmpty
              ? user.displayName
              : (user.username.isNotEmpty ? user.username : 'Ng∆∞·ªùi d√πng');
          if (senderAvatar == null) {
            senderAvatar = user.avatarUrl;

            debugPrint('üì± Found user: $senderName, avatar: $senderAvatar');
          } else {
            debugPrint('üì± User not found for senderId: $senderId');
          }
        } catch (e) {
          debugPrint('Error fetching user info for notification: $e');
        }
      }

      // N·∫øu l√† nh√≥m v√† kh√¥ng t√¨m th·∫•y sender name, d√πng t√™n nh√≥m
      if (senderName == 'Ng∆∞·ªùi d√πng' && isGroup) {
        final groupName = conversationData['name'] as String?;
        if (groupName != null && groupName.isNotEmpty) {
          senderName = groupName;
        } else {
          senderName = 'Nh√≥m chat';
        }
      }

      // Format message content
      final content = messageData['content'] as Map<String, dynamic>?;
      String messageText = '';
      String contentType = 'text';

      if (content != null) {
        contentType = content['type'] as String? ?? 'text';
        switch (contentType) {
          case 'text':
            messageText = content['text'] as String? ?? '';
            break;
          case 'audio':
            messageText = 'üé§ [Tin nh·∫Øn tho·∫°i]';
            break;
          case 'media':
            messageText = 'üñºÔ∏è [ƒêa ph∆∞∆°ng ti·ªán]';
            break;
          case 'file':
            messageText = 'üìÅ [T·ªáp tin]';
            break;
          default:
            messageText = 'ƒê√£ g·ª≠i tin nh·∫Øn';
        }
      }

      // Format title - d√πng t√™n nh√≥m n·∫øu l√† nh√≥m, kh√¥ng th√¨ d√πng senderName
      final String title = isGroup
          ? (conversationData['name'] as String? ?? senderName)
          : senderName;

      // L·∫•y th√¥ng tin conversation ƒë·ªÉ th√™m v√†o payload (cho navigation)
      final participants = List<Map<String, dynamic>>.from(
        conversationData['participants'] ?? [],
      );
      final memberIds = participants
          .map((p) => (p['userId']?.toString() ?? p['id']?.toString() ?? ''))
          .where((id) => id.isNotEmpty)
          .toList();

      debugPrint(
        'üì± Showing notification - Title: $title, Body: $messageText, SenderName: $senderName, Avatar: $senderAvatar',
      );

      // T·∫°o payload v·ªõi ƒë·∫ßy ƒë·ªß th√¥ng tin ƒë·ªÉ navigate ƒë√∫ng ChatScreen
      final payload = {
        'conversation_id': conversationId,
        'sender_id': senderId,
        'sender_name': senderName,
        'sender_avatar': senderAvatar ?? '',
        'content_type': contentType,
        'has_reply': 'true',
        'is_group': isGroup.toString(),
        'chat_name': title,
        'avatar_url': isGroup
            ? (conversationData['avatarUrl'] as String? ?? '')
            : (senderAvatar ?? ''),
        'member_ids': memberIds.join(','),
        'member_count': participants.length.toString(),
      };

      // T·∫°o payload JSON string ƒë√∫ng format
      final payloadString = jsonEncode(payload);

      debugPrint('üì± Notification payload: $payloadString');

      // Hi·ªÉn th·ªã notification v·ªõi avatar v√† MessagingStyle
      await notificationService.showNotification(
        title: title,
        body: messageText.isNotEmpty ? messageText : 'ƒê√£ g·ª≠i tin nh·∫Øn',
        payload: payloadString,
        senderAvatarUrl: senderAvatar,
        senderName: senderName,
        conversationId: conversationId,
        hasReply: true,
      );

      debugPrint('üì± Notification shown successfully');
    } catch (e) {
      debugPrint('Error in _showMessageNotification: $e');
    }
  }

  void _handleConversationSeen(Map<String, dynamic>? payload) {
    if (payload == null || _currentUserId == null) return;

    final conversationId = payload['conversationId'];
    if (conversationId == null) return;

    // Khi m·ªôt conversation ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† ƒë√£ ƒë·ªçc, reload count
    _loadUnreadCount();
  }

  // G·ªçi method n√†y khi user v√†o MessagesScreen ƒë·ªÉ reload count
  Future<void> refresh() async {
    await _getCurrentUserId();
    await _loadUnreadCount();
  }

  // Reset unread count khi user ƒë√£ v√†o MessagesScreen (ƒë√£ xem r·ªìi)
  void markAllAsSeen() {
    _unreadConversationCount = 0;
    notifyListeners();
  }

  @override
  void dispose() {
    _webSocketSubscription?.cancel();
    _debounceTimer?.cancel();
    super.dispose();
  }
}
